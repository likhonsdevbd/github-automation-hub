"""
Automated Security Vulnerability Scanner
Supports multiple security scanning tools and comprehensive vulnerability detection.
"""

import subprocess
import json
import os
import re
from pathlib import Path
from typing import Dict, List, Any, Optional
import xml.etree.ElementTree as ET


class VulnerabilityScanner:
    """Main vulnerability scanner orchestrator"""
    
    def __init__(self, project_path: Path):
        self.project_path = Path(project_path)
        self.results = {}
        
    def scan_all(self) -> Dict[str, Any]:
        """Run all vulnerability scans"""
        results = {}
        
        # Run Semgrep scan
        results['semgrep'] = self._run_semgrep()
        
        # Run Bandit scan
        results['bandit'] = self._run_bandit()
        
        # Run Safety scan for Python dependencies
        results['safety'] = self._run_safety()
        
        # Run custom security checks
        results['custom_checks'] = self._run_custom_security_checks()
        
        # Aggregate results
        results['summary'] = self._generate_summary(results)
        
        return results
    
    def scan_with_tools(self, tools: List[str]) -> Dict[str, Any]:
        """Run scans with specific tools"""
        results = {}
        
        if 'all' in tools or 'semgrep' in tools:
            results['semgrep'] = self._run_semgrep()
        
        if 'all' in tools or 'bandit' in tools:
            results['bandit'] = self._run_bandit()
        
        if 'all' in tools or 'safety' in tools:
            results['safety'] = self._run_safety()
        
        if 'all' in tools:
            results['custom_checks'] = self._run_custom_security_checks()
        
        results['summary'] = self._generate_summary(results)
        
        return results
    
    def _run_semgrep(self) -> Dict[str, Any]:
        """Run Semgrep security scan"""
        print("  Running Semgrep scan...")
        
        try:
            # Run Semgrep with JSON output
            cmd = [
                'semgrep', 
                '--config=auto',
                '--json',
                '--output=semgrep_results.json',
                str(self.project_path)
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_path)
            
            if result.returncode == 0:
                # Parse Semgrep results
                with open('semgrep_results.json', 'r') as f:
                    semgrep_data = json.load(f)
                
                os.remove('semgrep_results.json')
                
                return {
                    'status': 'success',
                    'results': semgrep_data,
                    'total_findings': len(semgrep_data.get('results', [])),
                    'severity_breakdown': self._analyze_semgrep_severity(semgrep_data)
                }
            else:
                return {
                    'status': 'error',
                    'error': result.stderr,
                    'note': 'Semgrep may not be installed or available'
                }
                
        except FileNotFoundError:
            return {
                'status': 'skipped',
                'reason': 'Semgrep not installed',
                'install_command': 'pip install semgrep'
            }
        except Exception as e:
            return {
                'status': 'error',
                'error': str(e)
            }
    
    def _run_bandit(self) -> Dict[str, Any]:
        """Run Bandit security scan"""
        print("  Running Bandit scan...")
        
        try:
            cmd = [
                'bandit',
                '-r',
                str(self.project_path),
                '-f', 'json'
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, cwd=self.project_path)
            
            if result.returncode in [0, 1]:  # 1 means issues found
                bandit_data = json.loads(result.stdout)
                
                return {
                    'status': 'success',
                    'results': bandit_data,
                    'total_findings': bandit_data.get('metrics', {}).get('_totals', {}).get('CONFIDENCE.HIGH', 0),
                    'severity_breakdown': self._analyze_bandit_severity(bandit_data)
                }
            else:
                return {
                    'status': 'error',
                    'error': result.stderr
                }
                
        except FileNotFoundError:
            return {
                'status': 'skipped',
                'reason': 'Bandit not installed',
                'install_command': 'pip install bandit'
            }
        except Exception as e:
            return {
                'status': 'error',
                'error': str(e)
            }
    
    def _run_safety(self) -> Dict[str, Any]:
        """Run Safety scan for dependency vulnerabilities"""
        print("  Running Safety scan...")
        
        try:
            # Check for common dependency files
            dep_files = list(self.project_path.rglob("requirements*.txt")) + \
                       list(self.project_path.rglob("pyproject.toml")) + \
                       list(self.project_path.rglob("Pipfile")) + \
                       list(self.project_path.rglob("poetry.lock"))
            
            if not dep_files:
                return {
                    'status': 'no_dependencies',
                    'reason': 'No dependency files found'
                }
            
            results = []
            
            for dep_file in dep_files:
                try:
                    cmd = [
                        'safety',
                        'check',
                        '-r', str(dep_file),
                        '--json'
                    ]
                    
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    
                    if result.stdout.strip():
                        safety_data = json.loads(result.stdout)
                        results.append({
                            'file': str(dep_file.relative_to(self.project_path)),
                            'vulnerabilities': safety_data
                        })
                        
                except json.JSONDecodeError:
                    # Safety might output text instead of JSON
                    continue
                except Exception as e:
                    results.append({
                        'file': str(dep_file.relative_to(self.project_path)),
                        'error': str(e)
                    })
            
            return {
                'status': 'success',
                'results': results,
                'scanned_files': len(dep_files)
            }
            
        except FileNotFoundError:
            return {
                'status': 'skipped',
                'reason': 'Safety not installed',
                'install_command': 'pip install safety'
            }
        except Exception as e:
            return {
                'status': 'error',
                'error': str(e)
            }
    
    def _run_custom_security_checks(self) -> Dict[str, Any]:
        """Run custom security checks"""
        print("  Running custom security checks...")
        
        checks = [
            self._check_hardcoded_secrets,
            self._check_insecure_random,
            self._check_sql_injection_patterns,
            self._check_command_injection_patterns,
            self._check_weak_crypto_patterns,
            self._check_permissions
        ]
        
        results = []
        
        for check_func in checks:
            try:
                result = check_func()
                if result['issues']:
                    results.append(result)
            except Exception as e:
                results.append({
                    'check': check_func.__name__,
                    'error': str(e)
                })
        
        return {
            'status': 'success',
            'checks_performed': len(checks),
            'results': results
        }
    
    def _check_hardcoded_secrets(self) -> Dict[str, Any]:
        """Check for hardcoded secrets and credentials"""
        patterns = [
            r'api[_-]?key["\'\s]*[:=]["\'\s]*([a-zA-Z0-9]{20,})',
            r'secret[_-]?key["\'\s]*[:=]["\'\s]*([a-zA-Z0-9]{20,})',
            r'password["\'\s]*[:=]["\'\s]*([^"\'\\s]{8,})',
            r'token["\'\s]*[:=]["\'\s]*([a-zA-Z0-9]{20,})',
            r'db[_-]?password["\'\s]*[:=]["\'\s]*([^"\'\\s]{8,})',
            r'private[_-]?key["\'\s]*[:=]["\'\s]*["\'](-----BEGIN.*?END.*?-----)["\']',
        ]
        
        issues = []
        
        for file_path in self.project_path.rglob("*.py"):
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    for line_num, line in enumerate(content.splitlines(), 1):
                        for pattern in patterns:
                            matches = re.finditer(pattern, line, re.IGNORECASE | re.MULTILINE)
                            for match in matches:
                                issues.append({
                                    'file': str(file_path.relative_to(self.project_path)),
                                    'line': line_num,
                                    'issue': f'Potential hardcoded secret: {match.group(1)[:10]}...',
                                    'severity': 'high',
                                    'pattern': pattern
                                })
            except Exception:
                continue
        
        return {
            'check': 'hardcoded_secrets',
            'issues': issues,
            'total_issues': len(issues)
        }
    
    def _check_insecure_random(self) -> Dict[str, Any]:
        """Check for insecure random number generation"""
        patterns = [
            r'random\.random\(\)',
            r'random\.randrange\(',
            r'random\.randint\(',
            r'random\.choice\(',
            r'random\.shuffle\(',
        ]
        
        issues = []
        
        for file_path in self.project_path.rglob("*.py"):
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    for line_num, line in enumerate(content.splitlines(), 1):
                        for pattern in patterns:
                            if re.search(pattern, line):
                                issues.append({
                                    'file': str(file_path.relative_to(self.project_path)),
                                    'line': line_num,
                                    'issue': 'Use of insecure random number generator',
                                    'suggestion': 'Use secrets module for cryptographic operations',
                                    'severity': 'medium'
                                })
            except Exception:
                continue
        
        return {
            'check': 'insecure_random',
            'issues': issues,
            'total_issues': len(issues)
        }
    
    def _check_sql_injection_patterns(self) -> Dict[str, Any]:
        """Check for SQL injection vulnerabilities"""
        patterns = [
            r'execute\s*\(\s*["\'].*%.*["\']',
            r'execute\s*\(\s*["\'].*\+.*["\']',
            r'cursor\.execute\s*\(\s*["\'].*%.*["\']',
        ]
        
        issues = []
        
        for file_path in self.project_path.rglob("*.py"):
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    for line_num, line in enumerate(content.splitlines(), 1):
                        for pattern in patterns:
                            if re.search(pattern, line):
                                issues.append({
                                    'file': str(file_path.relative_to(self.project_path)),
                                    'line': line_num,
                                    'issue': 'Potential SQL injection vulnerability',
                                    'severity': 'high'
                                })
            except Exception:
                continue
        
        return {
            'check': 'sql_injection',
            'issues': issues,
            'total_issues': len(issues)
        }
    
    def _check_command_injection_patterns(self) -> Dict[str, Any]:
        """Check for command injection vulnerabilities"""
        patterns = [
            r'os\.system\s*\(\s*.*\+',
            r'subprocess\.call\s*\(\s*.*\+',
            r'subprocess\.run\s*\(\s*.*\+',
            r'os\.popen\s*\(\s*.*\+',
        ]
        
        issues = []
        
        for file_path in self.project_path.rglob("*.py"):
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    for line_num, line in enumerate(content.splitlines(), 1):
                        for pattern in patterns:
                            if re.search(pattern, line):
                                issues.append({
                                    'file': str(file_path.relative_to(self.project_path)),
                                    'line': line_num,
                                    'issue': 'Potential command injection vulnerability',
                                    'severity': 'high'
                                })
            except Exception:
                continue
        
        return {
            'check': 'command_injection',
            'issues': issues,
            'total_issues': len(issues)
        }
    
    def _check_weak_crypto_patterns(self) -> Dict[str, Any]:
        """Check for weak cryptographic patterns"""
        patterns = [
            r'hashlib\.md5\(\)',
            r'hashlib\.sha1\(\)',
            r'Crypto\.Cipher\.DES\(\)',
            r'DES\(',
        ]
        
        issues = []
        
        for file_path in self.project_path.rglob("*.py"):
            try:
                with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    for line_num, line in enumerate(content.splitlines(), 1):
                        for pattern in patterns:
                            if re.search(pattern, line):
                                issues.append({
                                    'file': str(file_path.relative_to(self.project_path)),
                                    'line': line_num,
                                    'issue': 'Use of weak cryptographic algorithm',
                                    'severity': 'medium'
                                })
            except Exception:
                continue
        
        return {
            'check': 'weak_crypto',
            'issues': issues,
            'total_issues': len(issues)
        }
    
    def _check_permissions(self) -> Dict[str, Any]:
        """Check for insecure file permissions"""
        import stat
        import stat
        
        issues = []
        
        for file_path in self.project_path.rglob("*.py"):
            try:
                file_stat = file_path.stat()
                mode = file_stat.st_mode
                
                # Check for world-writable files
                if mode & stat.S_IWOTH:
                    issues.append({
                        'file': str(file_path.relative_to(self.project_path)),
                        'issue': 'File is world-writable (insecure permission)',
                        'severity': 'medium'
                    })
                
                # Check for executable Python files that don't have #! shebang
                if mode & stat.S_IXUSR:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        first_line = f.readline().strip()
                        if not first_line.startswith('#!'):
                            issues.append({
                                'file': str(file_path.relative_to(self.project_path)),
                                'issue': 'Executable Python file missing shebang',
                                'severity': 'low'
                            })
            except Exception:
                continue
        
        return {
            'check': 'permissions',
            'issues': issues,
            'total_issues': len(issues)
        }
    
    def _analyze_semgrep_severity(self, data: Dict) -> Dict[str, int]:
        """Analyze severity distribution from Semgrep results"""
        severity_count = {'info': 0, 'warning': 0, 'error': 0}
        
        for result in data.get('results', []):
            severity = result.get('severity', '').lower()
            if severity in severity_count:
                severity_count[severity] += 1
        
        return severity_count
    
    def _analyze_bandit_severity(self, data: Dict) -> Dict[str, int]:
        """Analyze severity distribution from Bandit results"""
        severity_count = {'high': 0, 'medium': 0, 'low': 0}
        
        for issue in data.get('results', []):
            severity = issue.get('issue_severity', '').lower()
            if severity in severity_count:
                severity_count[severity] += 1
        
        return severity_count
    
    def _generate_summary(self, results: Dict) -> Dict[str, Any]:
        """Generate summary of all scan results"""
        summary = {
            'total_vulnerabilities': 0,
            'high_severity': 0,
            'medium_severity': 0,
            'low_severity': 0,
            'tools_executed': [],
            'scan_timestamp': str(datetime.now())
        }
        
        for tool, result in results.items():
            if tool == 'summary':
                continue
                
            if result.get('status') == 'success':
                summary['tools_executed'].append(tool)
                
                # Aggregate findings
                if 'total_findings' in result:
                    summary['total_vulnerabilities'] += result['total_findings']
                
                if 'severity_breakdown' in result:
                    severity_breakdown = result['severity_breakdown']
                    for severity, count in severity_breakdown.items():
                        if severity == 'high' or severity == 'error':
                            summary['high_severity'] += count
                        elif severity == 'medium' or severity == 'warning':
                            summary['medium_severity'] += count
                        elif severity == 'low' or severity == 'info':
                            summary['low_severity'] += count
        
        return summary


# Add missing import for datetime
from datetime import datetime